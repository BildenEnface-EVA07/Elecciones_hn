<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sección Informativa sobre Algoritmos</title>
    <link rel="stylesheet" href="Algoritmos.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-toggle" id="mobile-menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="#" class="nav-link">Inicio</a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link">Proceso de votación</a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link">Preguntas frecuentes</a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link active">Algoritmos</a>
                </li>
            </ul>
        </div>
    </nav>

    <main class="main-content">
        <h1 class="page-title">Sección Informativa sobre Algoritmos</h1>
        <p class="page-description">Aquí puedes ver distintos algoritmos, desde sus conceptos, hasta el código e incluso ejecutarlos.</p>

        <div class="algorithm-container">
            <div class="tabs">
                <button class="tab-button active" data-tab="avestruz">Algoritmo del Avestruz</button>
                <button class="tab-button" data-tab="banquero-simple">Algoritmo del Banquero (Recurso Único)</button>
                <button class="tab-button" data-tab="banquero-multi">Algoritmo del Banquero (Múltiples Recursos)</button>
                <button class="tab-button" data-tab="filosofos">Los Filósofos Comelones</button>
                <button class="tab-button" data-tab="lectores">Problema de los Lectores Escritores</button>
                <button class="tab-button" data-tab="barbero">Problema del Barbero Durmiente</button>
            </div>

            <div class="content-area">
                <div class="tab-content active" id="avestruz">
                    <div class="content-left">
                        <h3>Algoritmo del Avestruz</h3>
                        <p>El algoritmo del avestruz no es realmente un algoritmo en el sentido tradicional, sino más bien una estrategia o enfoque de diseño de sistemas. Se llama así en forma irónica, haciendo alusión al mito de que los avestruces entierran la cabeza en la arena cuando tienen miedo: es decir, ignorar un problema con la esperanza de que nunca ocurra.</p>
                        
                        <p>Consiste en ignorar intencionalmente condiciones de carrera o errores poco frecuentes en sistemas concurrentes o distribuidos, bajo la suposición de que:</p>
                        <ul>
                            <li>Son raros</li>
                            <li>El costo de manejarlos supera el beneficio</li>
                            <li>El sistema puede tolerar sus efectos ocasionales</li>
                        </ul>
                        
                        <p>Este enfoque se usa cuando los errores son tan infrecuentes que es más económico dejarlos pasar que invertir recursos significativos en prevenirlos.</p>
                    </div>
                    <div class="content-right">
                        <div class="code-container">
                            <pre><code id="code-avestruz">// Ejemplo de "Algoritmo del Avestruz" - Ignorar condiciones de carrera
let counter = 0;

function increment() {
    for (let i = 0; i < 1000; i++) {
        counter++;
    }
}

function simulateRaceCondition() {
    counter = 0;
    
    increment();
    increment();
    increment();
    
    return `Valor final del contador: ${counter}`;
}</code></pre>
                        </div>
                        <div class="console" id="console-avestruz">
                            <div class="console-header">Consola</div>
                            <div class="console-output">Escribe /run para ejecutar el codigo, y presiona Enter.</div>
                            <div class="console-input-container">
                                <span>$</span>
                                <input type="text" class="console-input" data-target="avestruz" placeholder="Escribe /run o /clear">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="banquero-simple">
                    <div class="content-left">
                        <h3>Algoritmo del Banquero (Recurso Único)</h3>
                        <p>El algoritmo del banquero es una técnica de prevención de interbloqueos desarrollada por Edsger Dijkstra. Su nombre proviene de la analogía con un banquero que debe decidir si otorgar préstamos a clientes basándose en si podrá recuperar el dinero.</p>
                        
                        <p>El algoritmo funciona manteniendo el sistema en un "estado seguro", donde existe al menos una secuencia de ejecución que permite que todos los procesos terminen sin interbloqueo.</p>
                        
                        <p><strong>Para un solo recurso:</strong> Se verifica si otorgar el recurso mantiene el sistema en estado seguro. Es una versión simplificada donde solo hay una cantidad total de un tipo de recurso.</p>
                        
                        <p>Es conservador pero efectivo para prevenir interbloqueos en sistemas con recursos limitados.</p>
                    </div>
                    <div class="content-right">
                        <div class="code-container">
                            <pre><code id="code-banquero-simple">// Algoritmo del Banquero - Versión simplificada para un recurso
class BankerAlgorithmSimple {
    constructor(totalResources) {
        this.total = totalResources;
        this.allocated = []; // Recursos asignados a cada proceso
        this.max = [];       // Máximo de recursos que cada proceso necesita
        this.available = totalResources; // Recursos disponibles
    }
    
    addProcess(allocated, max) {
        this.allocated.push(allocated);
        this.max.push(max);
        this.available -= allocated; // Reducir disponibles por lo ya asignado
    }
    
    isSafeState() {
        let work = this.available;
        let finish = new Array(this.allocated.length).fill(false);
        let safeSequence = [];
        
        let found = true;
        while (found) {
            found = false;
            for (let i = 0; i < this.allocated.length; i++) {
                // Si el proceso no ha terminado y su necesidad es menor o igual a 'work'
                if (!finish[i] && (this.max[i] - this.allocated[i]) <= work) {
                    work += this.allocated[i]; // Liberar recursos
                    finish[i] = true;
                    safeSequence.push(i);
                    found = true;
                }
            }
        }
        
        // Si todos los procesos terminaron, el estado es seguro
        return finish.every(f => f) ? safeSequence : null;
    }
}

function runBankerSimpleExample() {
    let banker = new BankerAlgorithmSimple(10); // Total de 10 unidades de recurso
    banker.addProcess(2, 5);  // Proceso 0: asignado 2, máximo 5 (necesita 3 más)
    banker.addProcess(3, 6);  // Proceso 1: asignado 3, máximo 6 (necesita 3 más)
    banker.addProcess(1, 3);  // Proceso 2: asignado 1, máximo 3 (necesita 2 más)
    
    let sequence = banker.isSafeState();
    return sequence ? 
        `Estado seguro encontrado. Secuencia: ${sequence.join(' -> ')}` :
        'Estado inseguro detectado';
}</code></pre>
                        </div>
                        <div class="console" id="console-banquero-simple">
                            <div class="console-header">Consola</div>
                            <div class="console-output">Escribe /run para ejecutar el codigo, y presiona Enter.</div>
                            <div class="console-input-container">
                                <span>$</span>
                                <input type="text" class="console-input" data-target="banquero-simple" placeholder="Escribe /run o /clear">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="banquero-multi">
                    <div class="content-left">
                        <h3>Algoritmo del Banquero (Múltiples Recursos)</h3>
                        <p>Esta es una extensión del algoritmo del banquero que maneja múltiples tipos de recursos, por ejemplo, A, B y C. Requiere un seguimiento más complejo de los recursos disponibles, asignados y las necesidades máximas de cada proceso.</p>
                        
                        <p><strong>Componentes clave:</strong></p>
                        <ul>
                            <li>**Available (Vector):** Número de instancias disponibles de cada tipo de recurso.</li>
                            <li>**Max (Matriz):** Número máximo de instancias de cada recurso que cada proceso puede solicitar.</li>
                            <li>**Allocation (Matriz):** Número de instancias de cada recurso actualmente asignadas a cada proceso.</li>
                            <li>**Need (Matriz):** Número restante de instancias de cada recurso que cada proceso aún necesita. `Need[i][j] = Max[i][j] - Allocation[i][j]`.</li>
                        </ul>
                        
                        <p>El algoritmo verifica si el sistema puede encontrar una secuencia segura de procesos para los cuales, si se les conceden sus recursos restantes, pueden completar sus tareas y liberar sus recursos, permitiendo que el siguiente proceso en la secuencia se complete, y así sucesivamente.</p>
                        <p>Si existe al menos una secuencia segura, el estado es seguro; de lo contrario, es inseguro y se previene la asignación que conduciría a un interbloqueo.</p>
                    </div>
                    <div class="content-right">
                        <div class="code-container">
                            <pre><code id="code-banquero-multi">// Algoritmo del Banquero - Múltiples Recursos
class BankerAlgorithmMulti {
    constructor(available, max, allocation) {
        this.available = [...available]; // Vector de recursos disponibles
        this.max = max;                   // Matriz Max (proceso x recurso)
        this.allocation = allocation;     // Matriz Allocation (proceso x recurso)
        this.numProcesses = max.length;
        this.numResources = available.length;
        this.need = this.calculateNeed(); // Matriz Need
        this.log = [];
    }

    calculateNeed() {
        let need = [];
        for (let i = 0; i < this.numProcesses; i++) {
            need[i] = [];
            for (let j = 0; j < this.numResources; j++) {
                need[i][j] = this.max[i][j] - this.allocation[i][j];
            }
        }
        return need;
    }

    isSafeState() {
        let work = [...this.available];
        let finish = new Array(this.numProcesses).fill(false);
        let safeSequence = [];

        let count = 0;
        while (count < this.numProcesses) {
            let found = false;
            for (let p = 0; p < this.numProcesses; p++) {
                if (!finish[p]) {
                    let canExecute = true;
                    for (let r = 0; r < this.numResources; r++) {
                        if (this.need[p][r] > work[r]) {
                            canExecute = false;
                            break;
                        }
                    }

                    if (canExecute) {
                        for (let r = 0; r < this.numResources; r++) {
                            work[r] += this.allocation[p][r];
                        }
                        safeSequence.push(p);
                        finish[p] = true;
                        found = true;
                        count++;
                    }
                }
            }

            if (!found) {
                this.log.push("No se encontró una secuencia segura.");
                return null;
            }
        }
        this.log.push("Se encontró una secuencia segura.");
        return safeSequence;
    }

    simulate() {
        this.log = [];
        this.log.push("Estado Inicial:");
        this.log.push(`Available: [${this.available.join(', ')}]`);
        this.log.push("Allocation:");
        this.allocation.forEach((alloc, i) => this.log.push(`P${i}: [${alloc.join(', ')}]`));
        this.log.push("Max:");
        this.max.forEach((m, i) => this.log.push(`P${i}: [${m.join(', ')}]`));
        this.log.push("Need:");
        this.need.forEach((n, i) => this.log.push(`P${i}: [${n.join(', ')}]`));
        
        const sequence = this.isSafeState();
        if (sequence) {
            this.log.push(`Secuencia segura: P${sequence.join(' -> P')}`);
        } else {
            this.log.push("El sistema está en un estado inseguro.");
        }
        return this.log.join('\n');
    }
}

function runBankerMultiExample() {
    // Ejemplo de un sistema con 3 tipos de recursos (A, B, C)
    // P0, P1, P2 son procesos
    const available = [3, 3, 2]; // Instancias disponibles de A, B, C

    const max = [ // Necesidades máximas de cada proceso
        [7, 5, 3], // P0
        [3, 2, 2], // P1
        [9, 0, 2]  // P2
    ];

    const allocation = [ // Recursos actualmente asignados a cada proceso
        [0, 1, 0], // P0
        [2, 0, 0], // P1
        [3, 0, 2]  // P2
    ];

    let banker = new BankerAlgorithmMulti(available, max, allocation);
    return banker.simulate();
}</code></pre>
                        </div>
                        <div class="console" id="console-banquero-multi">
                            <div class="console-header">Consola</div>
                            <div class="console-output">Escribe /run para ejecutar el codigo, y presiona Enter.</div>
                            <div class="console-input-container">
                                <span>$</span>
                                <input type="text" class="console-input" data-target="banquero-multi" placeholder="Escribe /run o /clear">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="filosofos">
                    <div class="content-left">
                        <h3>Problema de los Filósofos Comelones</h3>
                        <p>Este es un problema clásico de sincronización propuesto por Dijkstra. Cinco filósofos se sientan alrededor de una mesa circular con un plato de espaguetis frente a cada uno y cinco tenedores entre ellos.</p>
                        
                        <p>Cada filósofo alterna entre pensar y comer. Para comer, necesita ambos tenedores adyacentes. El problema surge cuando todos los filósofos toman el tenedor de su izquierda simultáneamente, causando un interbloqueo.</p>
                        
                        <p><strong>Soluciones comunes:</strong></p>
                        <ul>
                            <li>Permitir que máximo 4 filósofos coman a la vez</li>
                            <li>Filósofos impares toman primero tenedor izquierdo, pares el derecho</li>
                            <li>Usar un semáforo para controlar el acceso a los tenedores</li>
                        </ul>
                        
                        <p>Ilustra perfectamente los desafíos de la sincronización en sistemas concurrentes.</p>
                    </div>
                    <div class="content-right">
                        <div class="code-container">
                            <pre><code id="code-filosofos">// Problema de los Filósofos Comelones - Simulación
class DiningPhilosophers {
    constructor() {
        this.forks = [true, true, true, true, true]; // true = disponible
        this.philosophers = ['Aristóteles', 'Platón', 'Sócrates', 'Kant', 'Descartes'];
        this.log = [];
    }
    
    canEat(philosopher) {
        let leftFork = philosopher;
        let rightFork = (philosopher + 1) % 5;
        return this.forks[leftFork] && this.forks[rightFork];
    }
    
    eat(philosopher) {
        if (this.canEat(philosopher)) {
            let leftFork = philosopher;
            let rightFork = (philosopher + 1) % 5;
            
            this.forks[leftFork] = false;
            this.forks[rightFork] = false;
            
            this.log.push(`${this.philosophers[philosopher]} está comiendo`);
            
            setTimeout(() => {
                this.forks[leftFork] = true;
                this.forks[rightFork] = true;
                this.log.push(`${this.philosophers[philosopher]} terminó de comer`);
            }, 100);
            
            return true;
        }
        return false;
    }
    
    simulate() {
        this.log = [];
        
        for (let i = 0; i < 5; i++) {
            if (!this.eat(i)) {
                this.log.push(`${this.philosophers[i]} no puede comer (tenedores ocupados)`);
            }
        }
        
        return this.log.join('\n');
    }
}

function runPhilosophersExample() {
    let dining = new DiningPhilosophers();
    return dining.simulate();
}</code></pre>
                        </div>
                        <div class="console" id="console-filosofos">
                            <div class="console-header">Consola</div>
                            <div class="console-output">Escribe /run para ejecutar el codigo, y presiona Enter.</div>
                            <div class="console-input-container">
                                <span>$</span>
                                <input type="text" class="console-input" data-target="filosofos" placeholder="Escribe /run o /clear">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="lectores">
                    <div class="content-left">
                        <h3>Problema de Lectores y Escritores</h3>
                        <p>Este problema clásico de sincronización involucra múltiples procesos que acceden a un recurso compartido (como una base de datos). Los procesos se dividen en dos categorías:</p>
                        
                        <p><strong>Lectores:</strong> Solo leen el recurso, múltiples lectores pueden acceder simultáneamente sin problemas.</p>
                        <p><strong>Escritores:</strong> Modifican el recurso, requieren acceso exclusivo (no pueden haber otros lectores o escritores).</p>
                        
                        <p><strong>Restricciones:</strong></p>
                        <ul>
                            <li>Múltiples lectores pueden leer simultáneamente</li>
                            <li>Solo un escritor puede escribir a la vez</li>
                            <li>No pueden haber lectores y escritores simultáneos</li>
                        </ul>
                        
                        <p>Las soluciones varían en prioridad: prioridad a lectores, prioridad a escritores, o acceso justo.</p>
                    </div>
                    <div class="content-right">
                        <div class="code-container">
                            <pre><code id="code-lectores">// Problema de Lectores y Escritores
class ReadersWriters {
    constructor() {
        this.readers = 0;
        this.writing = false;
        this.data = "Contenido inicial";
        this.log = [];
    }
    
    startReading(readerId) {
        if (!this.writing) {
            this.readers++;
            this.log.push(`Lector ${readerId} comenzó a leer. Lectores activos: ${this.readers}`);
            this.log.push(`Lector ${readerId} lee: "${this.data}"`);
            return true;
        } else {
            this.log.push(`Lector ${readerId} no puede leer (escritor activo)`);
            return false;
        }
    }
    
    stopReading(readerId) {
        if (this.readers > 0) {
            this.readers--;
            this.log.push(`Lector ${readerId} terminó de leer. Lectores activos: ${this.readers}`);
        }
    }
    
    startWriting(writerId, newData) {
        if (this.readers === 0 && !this.writing) {
            this.writing = true;
            this.data = newData;
            this.log.push(`Escritor ${writerId} escribió: "${newData}"`);
            return true;
        } else {
            this.log.push(`Escritor ${writerId} no puede escribir (${this.readers} lectores o escritor activo)`);
            return false;
        }
    }
    
    stopWriting(writerId) {
        this.writing = false;
        this.log.push(`Escritor ${writerId} terminó de escribir`);
    }
    
    simulate() {
        this.log = [];
        
        this.startReading(1);
        this.startReading(2);
        this.startWriting(1, "Nuevo contenido");
        this.stopReading(1);
        this.stopReading(2);
        this.startWriting(1, "Contenido actualizado");
        this.stopWriting(1);
        this.startReading(3);
        this.stopReading(3);
        
        return this.log.join('\n');
    }
}

function runReadersWritersExample() {
    let rw = new ReadersWriters();
    return rw.simulate();
}</code></pre>
                        </div>
                        <div class="console" id="console-lectores">
                            <div class="console-header">Consola</div>
                            <div class="console-output">Escribe /run para ejecutar el codigo, y presiona Enter.</div>
                            <div class="console-input-container">
                                <span>$</span>
                                <input type="text" class="console-input" data-target="lectores" placeholder="Escribe /run o /clear">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="barbero">
                    <div class="content-left">
                        <h3>Problema del Barbero Durmiente</h3>
                        <p>Este problema clásico de sincronización, propuesto por Dijkstra, describe una barbería con un barbero, una silla de barbero y varias sillas de espera.</p>
                        
                        <p><strong>Reglas del problema:</strong></p>
                        <ul>
                            <li>Si no hay clientes, el barbero duerme en su silla</li>
                            <li>Cuando llega un cliente, debe despertar al barbero si está durmiendo</li>
                            <li>Si el barbero está ocupado, el cliente espera (si hay sillas disponibles)</li>
                            <li>Si no hay sillas de espera disponibles, el cliente se va</li>
                        </ul>
                        
                        <p>El desafío está en la sincronización: evitar condiciones de carrera donde el barbero y el cliente se pierdan mutuamente, o donde se cuenten mal los clientes en espera.</p>
                        
                        <p>Se resuelve típicamente usando semáforos para controlar el acceso a las sillas y la comunicación barbero-cliente.</p>
                    </div>
                    <div class="content-right">
                        <div class="code-container">
                            <pre><code id="code-barbero">// Problema del Barbero Durmiente
class SleepingBarber {
    constructor(waitingChairs = 5) {
        this.waitingChairs = waitingChairs;
        this.waitingCustomers = [];
        this.barberSleeping = true;
        this.cuttingHair = false;
        this.log = [];
    }
    
    customerArrives(customerId) {
        this.log.push(`Cliente ${customerId} llega a la barbería`);
        
        if (this.barberSleeping) {
            this.barberSleeping = false;
            this.cuttingHair = true;
            this.log.push(`Cliente ${customerId} despierta al barbero y se sienta`);
            this.cutHair(customerId);
        } else if (this.waitingCustomers.length < this.waitingChairs) {
            this.waitingCustomers.push(customerId);
            this.log.push(`Cliente ${customerId} espera. Cola: ${this.waitingCustomers.length}/${this.waitingChairs}`);
        } else {
            this.log.push(`Cliente ${customerId} se va (no hay sillas disponibles)`);
        }
    }
    
    cutHair(customerId) {
        this.log.push(`Barbero corta el cabello del cliente ${customerId}`);
        
        setTimeout(() => {
            this.log.push(`Cliente ${customerId} terminó su corte`);
            this.cuttingHair = false;
            
            if (this.waitingCustomers.length > 0) {
                let nextCustomer = this.waitingCustomers.shift();
                this.cuttingHair = true;
                this.log.push(`Siguiente cliente ${nextCustomer} se sienta`);
                this.cutHair(nextCustomer);
            } else {
                this.barberSleeping = true;
                this.log.push(`Barbero se duerme (no hay más clientes)`);
            }
        }, 100);
    }
    
    simulate() {
        this.log = [];
        this.waitingCustomers = [];
        this.barberSleeping = true;
        this.cuttingHair = false;
        
        this.customerArrives(1);
        this.customerArrives(2);
        this.customerArrives(3);
        this.customerArrives(4);
        this.customerArrives(5);
        this.customerArrives(6);
        this.customerArrives(7);
        
        return this.log.join('\n');
    }
}

function runBarberExample() {
    let barber = new SleepingBarber(3);
    return barber.simulate();
}</code></pre>
                        </div>
                        <div class="console" id="console-barbero">
                            <div class="console-header">Consola</div>
                            <div class="console-output">Escribe /run para ejecutar el codigo, y presiona Enter.</div>
                            <div class="console-input-container">
                                <span>$</span>
                                <input type="text" class="console-input" data-target="barbero" placeholder="Escribe /run o /clear">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <p>Heyden Aldana - Héctor Funes - Bilander Fernández</p>
        <p>Copyright © todos los derechos reservados.</p>
        <p>Este es un proyecto simulado y no corresponde al modelo actual del sistema de elecciones generales en Honduras</p>
    </footer>

    <script>
        // Navegación móvil
        const mobileMenu = document.getElementById('mobile-menu');
        const navMenu = document.querySelector('.nav-menu');

        mobileMenu.addEventListener('click', function() {
            mobileMenu.classList.toggle('is-active');
            navMenu.classList.toggle('active');
        });

        // Sistema de pestañas
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                const targetTab = this.getAttribute('data-tab');
                
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                this.classList.add('active');
                document.getElementById(targetTab).classList.add('active');

                // Limpiar y resetear la consola al cambiar de pestaña
                const currentConsoleInput = document.querySelector(`#console-${targetTab} .console-input`);
                const currentConsoleOutput = document.querySelector(`#console-${targetTab} .console-output`);
                if (currentConsoleOutput) {
                    currentConsoleOutput.textContent = "Escribe /run para ejecutar el codigo, y presiona Enter.";
                }
                if (currentConsoleInput) {
                    currentConsoleInput.value = "";
                    currentConsoleInput.focus();
                }
            });
        });

        // Funcionalidad de la consola interactiva
        document.querySelectorAll('.console-input').forEach(input => {
            input.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const command = this.value.trim();
                    const algorithmId = this.dataset.target;
                    const consoleOutput = document.querySelector(`#console-${algorithmId} .console-output`);
                    
                    if (command === '/run') {
                        executeAlgorithmCode(algorithmId, consoleOutput);
                    } else if (command === '/clear') {
                        consoleOutput.textContent = "";
                    } else {
                        consoleOutput.textContent = "ERROR: comando no válido";
                    }
                    this.value = '';
                }
            });
        });

        function executeAlgorithmCode(algorithm, consoleOutputElement) {
            try {
                let result;
                switch(algorithm) {
                    case 'avestruz':
                        result = simulateRaceCondition();
                        break;
                    case 'banquero-simple':
                        result = runBankerSimpleExample();
                        break;
                    case 'banquero-multi':
                        result = runBankerMultiExample();
                        break;
                    case 'filosofos':
                        result = runPhilosophersExample();
                        break;
                    case 'lectores':
                        result = runReadersWritersExample();
                        break;
                    case 'barbero':
                        result = runBarberExample();
                        break;
                    default:
                        result = 'Algoritmo no encontrado';
                }
                
                consoleOutputElement.textContent = result;
            } catch (error) {
                consoleOutputElement.textContent = `Error al ejecutar: ${error.message}`;
            }
        }

        let counter = 0;

        function increment() {
            for (let i = 0; i < 1000; i++) {
                counter++;
            }
        }

        function simulateRaceCondition() {
            counter = 0;
            increment();
            increment();
            increment();
            return `Valor final del contador: ${counter}`;
        }

        class BankerAlgorithmSimple {
            constructor(totalResources) {
                this.total = totalResources;
                this.allocated = [];
                this.max = [];
                this.available = totalResources;
            }
            
            addProcess(allocated, max) {
                this.allocated.push(allocated);
                this.max.push(max);
                this.available -= allocated;
            }
            
            isSafeState() {
                let work = this.available;
                let finish = new Array(this.allocated.length).fill(false);
                let safeSequence = [];
                
                let found = true;
                while (found) {
                    found = false;
                    for (let i = 0; i < this.allocated.length; i++) {
                        if (!finish[i] && (this.max[i] - this.allocated[i]) <= work) {
                            work += this.allocated[i];
                            finish[i] = true;
                            safeSequence.push(i);
                            found = true;
                        }
                    }
                }
                
                return finish.every(f => f) ? safeSequence : null;
            }
        }

        function runBankerSimpleExample() {
            let banker = new BankerAlgorithmSimple(10);
            banker.addProcess(2, 5);
            banker.addProcess(3, 6);
            banker.addProcess(1, 3);
            
            let sequence = banker.isSafeState();
            return sequence ? 
                `Estado seguro encontrado. Secuencia: ${sequence.join(' -> ')}` :
                'Estado inseguro detectado';
        }

        class BankerAlgorithmMulti {
            constructor(available, max, allocation) {
                this.available = [...available];
                this.max = max;
                this.allocation = allocation;
                this.numProcesses = max.length;
                this.numResources = available.length;
                this.need = this.calculateNeed();
                this.log = [];
            }

            calculateNeed() {
                let need = [];
                for (let i = 0; i < this.numProcesses; i++) {
                    need[i] = [];
                    for (let j = 0; j < this.numResources; j++) {
                        need[i][j] = this.max[i][j] - this.allocation[i][j];
                    }
                }
                return need;
            }

            isSafeState() {
                let work = [...this.available];
                let finish = new Array(this.numProcesses).fill(false);
                let safeSequence = [];

                let count = 0;
                while (count < this.numProcesses) {
                    let found = false;
                    for (let p = 0; p < this.numProcesses; p++) {
                        if (!finish[p]) {
                            let canExecute = true;
                            for (let r = 0; r < this.numResources; r++) {
                                if (this.need[p][r] > work[r]) {
                                    canExecute = false;
                                    break;
                                }
                            }

                            if (canExecute) {
                                for (let r = 0; r < this.numResources; r++) {
                                    work[r] += this.allocation[p][r];
                                }
                                safeSequence.push(p);
                                finish[p] = true;
                                found = true;
                                count++;
                            }
                        }
                    }

                    if (!found) {
                        this.log.push("No se encontró una secuencia segura.");
                        return null;
                    }
                }
                this.log.push("Se encontró una secuencia segura.");
                return safeSequence;
            }

            simulate() {
                this.log = [];
                this.log.push("Estado Inicial:");
                this.log.push(`Available: [${this.available.join(', ')}]`);
                this.log.push("Allocation:");
                this.allocation.forEach((alloc, i) => this.log.push(`P${i}: [${alloc.join(', ')}]`));
                this.log.push("Max:");
                this.max.forEach((m, i) => this.log.push(`P${i}: [${m.join(', ')}]`));
                this.log.push("Need:");
                this.need.forEach((n, i) => this.log.push(`P${i}: [${n.join(', ')}]`));
                
                const sequence = this.isSafeState();
                if (sequence) {
                    this.log.push(`Secuencia segura: P${sequence.join(' -> P')}`);
                } else {
                    this.log.push("El sistema está en un estado inseguro.");
                }
                return this.log.join('\n');
            }
        }

        function runBankerMultiExample() {
            const available = [3, 3, 2];
            const max = [
                [7, 5, 3],
                [3, 2, 2],
                [9, 0, 2]
            ];
            const allocation = [
                [0, 1, 0],
                [2, 0, 0],
                [3, 0, 2]
            ];

            let banker = new BankerAlgorithmMulti(available, max, allocation);
            return banker.simulate();
        }

        class DiningPhilosophers {
            constructor() {
                this.forks = [true, true, true, true, true];
                this.philosophers = ['Aristóteles', 'Platón', 'Sócrates', 'Kant', 'Descartes'];
                this.log = [];
            }
            
            canEat(philosopher) {
                let leftFork = philosopher;
                let rightFork = (philosopher + 1) % 5;
                return this.forks[leftFork] && this.forks[rightFork];
            }
            
            eat(philosopher) {
                if (this.canEat(philosopher)) {
                    let leftFork = philosopher;
                    let rightFork = (philosopher + 1) % 5;
                    
                    this.forks[leftFork] = false;
                    this.forks[rightFork] = false;
                    
                    this.log.push(`${this.philosophers[philosopher]} está comiendo`);
                    
                    setTimeout(() => {
                        this.forks[leftFork] = true;
                        this.forks[rightFork] = true;
                        this.log.push(`${this.philosophers[philosopher]} terminó de comer`);
                    }, 100);
                    
                    return true;
                }
                return false;
            }
            
            simulate() {
                this.log = [];
                
                for (let i = 0; i < 5; i++) {
                    if (!this.eat(i)) {
                        this.log.push(`${this.philosophers[i]} no puede comer (tenedores ocupados)`);
                    }
                }
                
                return this.log.join('\n');
            }
        }

        function runPhilosophersExample() {
            let dining = new DiningPhilosophers();
            return dining.simulate();
        }

        class ReadersWriters {
            constructor() {
                this.readers = 0;
                this.writing = false;
                this.data = "Contenido inicial";
                this.log = [];
            }
            
            startReading(readerId) {
                if (!this.writing) {
                    this.readers++;
                    this.log.push(`Lector ${readerId} comenzó a leer. Lectores activos: ${this.readers}`);
                    this.log.push(`Lector ${readerId} lee: "${this.data}"`);
                    return true;
                } else {
                    this.log.push(`Lector ${readerId} no puede leer (escritor activo)`);
                    return false;
                }
            }
            
            stopReading(readerId) {
                if (this.readers > 0) {
                    this.readers--;
                    this.log.push(`Lector ${readerId} terminó de leer. Lectores activos: ${this.readers}`);
                }
            }
            
            startWriting(writerId, newData) {
                if (this.readers === 0 && !this.writing) {
                    this.writing = true;
                    this.data = newData;
                    this.log.push(`Escritor ${writerId} escribió: "${newData}"`);
                    return true;
                } else {
                    this.log.push(`Escritor ${writerId} no puede escribir (${this.readers} lectores o escritor activo)`);
                    return false;
                }
            }
            
            stopWriting(writerId) {
                this.writing = false;
                this.log.push(`Escritor ${writerId} terminó de escribir`);
            }
            
            simulate() {
                this.log = [];
                
                this.startReading(1);
                this.startReading(2);
                this.startWriting(1, "Nuevo contenido");
                this.stopReading(1);
                this.stopReading(2);
                this.startWriting(1, "Contenido actualizado");
                this.stopWriting(1);
                this.startReading(3);
                this.stopReading(3);
                
                return this.log.join('\n');
            }
        }

        function runReadersWritersExample() {
            let rw = new ReadersWriters();
            return rw.simulate();
        }

        class SleepingBarber {
            constructor(waitingChairs = 5) {
                this.waitingChairs = waitingChairs;
                this.waitingCustomers = [];
                this.barberSleeping = true;
                this.cuttingHair = false;
                this.log = [];
            }
            
            customerArrives(customerId) {
                this.log.push(`Cliente ${customerId} llega a la barbería`);
                
                if (this.barberSleeping) {
                    this.barberSleeping = false;
                    this.cuttingHair = true;
                    this.log.push(`Cliente ${customerId} despierta al barbero y se sienta`);
                    this.cutHair(customerId);
                } else if (this.waitingCustomers.length < this.waitingChairs) {
                    this.waitingCustomers.push(customerId);
                    this.log.push(`Cliente ${customerId} espera. Cola: ${this.waitingCustomers.length}/${this.waitingChairs}`);
                } else {
                    this.log.push(`Cliente ${customerId} se va (no hay sillas disponibles)`);
                }
            }
            
            cutHair(customerId) {
                this.log.push(`Barbero corta el cabello del cliente ${customerId}`);
                
                setTimeout(() => {
                    this.log.push(`Cliente ${customerId} terminó su corte`);
                    this.cuttingHair = false;
                    
                    if (this.waitingCustomers.length > 0) {
                        let nextCustomer = this.waitingCustomers.shift();
                        this.cuttingHair = true;
                        this.log.push(`Siguiente cliente ${nextCustomer} se sienta`);
                        this.cutHair(nextCustomer);
                    } else {
                        this.barberSleeping = true;
                        this.log.push(`Barbero se duerme (no hay más clientes)`);
                    }
                }, 100);
            }
            
            simulate() {
                this.log = [];
                this.waitingCustomers = [];
                this.barberSleeping = true;
                this.cuttingHair = false;
                
                this.customerArrives(1);
                this.customerArrives(2);
                this.customerArrives(3);
                this.customerArrives(4);
                this.customerArrives(5);
                this.customerArrives(6);
                this.customerArrives(7);
                
                return this.log.join('\n');
            }
        }

        function runBarberExample() {
            let barber = new SleepingBarber(3);
            return barber.simulate();
        }
    </script>
</body>
</html>